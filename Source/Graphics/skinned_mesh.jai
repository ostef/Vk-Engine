SkinnedVertex :: struct {
    position : Vec3f;
    normal : Vec3f;
    tangent : Vec4f;
    tex_coords : Vec2f;
    joint_ids : Vec4s;
    joint_weights : Vec3f;
}

SkinnedMesh :: struct {
    #as using _ : Mesh(SkinnedVertex);
    #as using,except(memory_block) armature : Armature;
} @Asset

Max_Joints :: 1000;
Max_Armature_Joint_Name_Length :: 64;

ArmatureJoint :: struct {
    id : s16;

    local_bind_position : Vec3f;
    local_bind_orientation : Quatf;
    local_bind_scale : Vec3f;

    inverse_bind_transform : Mat4f;
    parent : *ArmatureJoint;
}

Armature :: struct {
    joint_count : s64;
    memory_block : *void;
    // Layout of the memory:
    // [joint_count]ArmatureJoint
    // [joint_count][Max_Armature_Joint_Name_Length]u8
    // [map_capacity]HashMap(string, s16).Entry

    #place joint_count;
    joints : []ArmatureJoint;
    name_to_joint_id : HashMap(string, s16);
}

CalculateArmatureMemoryBlockSize :: (joint_count : s64) -> s64 {
    map_capacity := HashMapGetMinCapacityForElementCount(Armature.name_to_joint_id.Load_Factor, joint_count);

    return size_of(ArmatureJoint) * joint_count
        + Max_Armature_Joint_Name_Length * joint_count
        + size_of(Armature.name_to_joint_id.Entry) * map_capacity;
}

AllocArmatureData :: (armature : *Armature, joint_count : s64) {
    size := CalculateArmatureMemoryBlockSize(joint_count);
    armature.joint_count = joint_count;
    armature.memory_block = Alloc(size);

    // This below is redundant since joints.data has the same offset as memory_block
    // armature.joints.data = armature.memory_block;
    // armature.joints.count = joint_count;

    map_data := armature.memory_block + size_of(ArmatureJoint) * joint_count;
    map_data += Max_Armature_Joint_Name_Length * joint_count;
    capacity := HashMapGetMinCapacityForElementCount(armature.name_to_joint_id, joint_count);

    HashMapInitFromPreallocatedMemory(*armature.name_to_joint_id, map_data, capacity, Trap);
}

FreeArmatureData :: (using armature : *Armature) {
    Free(memory_block);
    Initialize(armature);
}

GetJointNamesArray :: (using armature : Armature) -> [][Max_Armature_Joint_Name_Length]u8 {
    result : [][Max_Armature_Joint_Name_Length]u8 = ---;
    result.count = joint_count;
    result.data = memory_block + size_of(ArmatureJoint) * joint_count;

    return result;
}

GetJointName :: (armature : Armature, joint_id : s16) -> string {
    names := GetJointNamesArray(armature);

    return MakeString(names[joint_id].data);
}

LoadSkinnedMeshFromMemory :: (mesh : *SkinnedMesh, data : []u8, name : string) -> bool {
    #import "Binary_Reader";

    reader := MakeBinaryReader(data);

    if EqualsString(*reader, "STATIC_MESH") {
        LogError("Trying to load static mesh as skinned mesh");
        return false;
    }

    str, ok := ReadString(*reader, "SKINNED_MESH".count);
    if !ok || str != "SKINNED_MESH" {
        LogError("Not a skinned mesh file");
        return false;
    }

    version:, ok = ReadValue(*reader, u32);
    if !ok {
        LogError("Could not read file version");
        return false;
    }

    if version != MakeVersionNumber(1, 0, 0) {
        LogError("Unknown version %", version);
        return false;
    }

    flags:, ok = ReadValue(*reader, MeshFileFlags);
    if !ok {
        LogError("Could not read flags");
        return false;
    }

    vertex_count:, ok = ReadValue(*reader, u32);
    if !ok {
        LogError("Could not read vertex count");
        return false;
    }

    triangle_count:, ok = ReadValue(*reader, u32);
    if !ok {
        LogError("Could not read triangle count");
        return false;
    }

    index_count := triangle_count * 3;

    mesh.vertices = AllocArray(SkinnedVertex, vertex_count);
    mesh.vertex_count = xx vertex_count;

    mesh.indices = AllocArray(u32, index_count);
    mesh.index_count = xx index_count;

    ok = ReadArray(*reader, mesh.vertices);
    if !ok {
        LogError("Could not read vertices");
        return false;
    }

    ok = ReadArray(*reader, mesh.indices);
    if !ok {
        LogError("Could not read indices");
        return false;
    }

    joint_count:, ok = ReadValue(*reader, s16);
    if !ok {
        LogError("Could not read joint count");
        return false;
    }

    if joint_count < 0 {
        LogError("Invalid negative joint count");
        return false;
    }

    if joint_count > Max_Joints {
        LogError("Too many joints in mesh (%)", joint_count);
        return false;
    }

    AllocArmatureData(*mesh.armature, joint_count);
    joint_names := GetJointNamesArray(*mesh.armature);

    for i : 0..joint_count - 1 {
        name:, ok = ReadNullTerminatedString(*reader);
        if !ok {
            LogError("Could not read joint % name", i);
            return false;
        }

        if name.count == 0 || name.count >= Max_Armature_Joint_Name_Length {
            LogError("Invalid joint name %", name);
            return false;
        }

        joint_name := joint_names[i].data;
        memcpy(joint_name, name.data, name.count + 1);
        name.data = joint_name;

        _, was_present := HashMapInsert(*mesh.name_to_joint_id, name, i);
        if was_present {
            LogError("Duplicate joint %", name);
            return false;
        }

        joint := *mesh.joints[i];
        joint.id = i;

        joint.local_bind_position, ok = ReadValue(*reader, Vec3f);
        if !ok {
            LogError("Could not read joint % local bind position", name);
            return false;
        }

        joint.local_bind_orientation, ok = ReadValue(*reader, Quatf);
        if !ok {
            LogError("Could not read joint % local bind orientation", name);
            return false;
        }

        joint.local_bind_scale, ok = ReadValue(*reader, Vec3f);
        if !ok {
            LogError("Could not read joint % local bind scale", name);
            return false;
        }

        parent_id:, ok = ReadValue(*reader, s16);
        if !ok {
            LogError("Could not read joint % parent id", name);
            return false;
        }

        local_bind_transform := Mat4fTransformSRT(joint.local_bind_position, joint.local_bind_orientation, joint.local_bind_scale);

        if parent_id >= 0 {
            if parent_id > joint.id {
                LogError("Parent id (%) for joint % is larger than the joint id (%)",
                    name, parent_id, joint.id);
                return false;
            }

            if parent_id == joint.id {
                LogError("Joint % is parented to itself", name);
                return false;
            }

            if parent_id >= mesh.joints.count {
                LogError("Invalid parent id for joint %", name);
                return false;
            }

            joint.parent = *mesh.joints[parent_id];
            joint.inverse_bind_transform = joint.parent.inverse_bind_transform
                * local_bind_transform;
        } else {
            joint.parent = null;
            joint.inverse_bind_transform = local_bind_transform;
        }
    }

    if !IsAtEnd(reader) {
        LogError("Trailing data (% bytes) in static mesh '%' file", reader.size - reader.offset, name);
    }

    for * mesh.joints {
        it.inverse_bind_transform = Inverse(it.inverse_bind_transform);
    }

    if !(flags & .HasTangents) {
        CalculateTangents(mesh);
    }

    if vertex_count > 0 {
        desc : GfxBufferDesc;
        desc.size = vertex_count * size_of(SkinnedVertex);
        desc.usage = .VertexBuffer;
        desc.memory_usage = .Upload;

        mesh.vertex_buffer = CreateGfxBuffer(TPrint("% vertices", name), desc);
        if IsNull(*mesh.vertex_buffer) {
            LogError("Could not create vertex buffer for mesh '%'", name);
            return false;
        }

        vmaCopyMemoryToAllocation(g_gfx_context.allocator, mesh.vertices.data, mesh.vertex_buffer.allocation, 0, desc.size);
    }

    if index_count > 0 {
        desc : GfxBufferDesc;
        desc.size = index_count * size_of(u32);
        desc.usage = .IndexBuffer;
        desc.memory_usage = .Upload;

        mesh.index_buffer = CreateGfxBuffer(TPrint("% indices", name), desc);
        if IsNull(*mesh.index_buffer) {
            LogError("Could not create index buffer for mesh '%'", name);
            return false;
        }

        vmaCopyMemoryToAllocation(g_gfx_context.allocator, mesh.indices.data, mesh.index_buffer.allocation, 0, desc.size);
    }

    return true;
}

LoadSkinnedMeshFromFile :: (mesh : *SkinnedMesh, filename : string) -> bool {
    data, ok := read_entire_file(filename);
    if !ok {
        return false;
    }

    ok = LoadSkinnedMeshFromMemory(mesh, xx data, filename);
    Free(data.data);

    return ok;
}

DestroySkinnedMesh :: (mesh : *SkinnedMesh) {
    DestroyMesh(mesh);
    FreeArmatureData(mesh);
}
